from __future__ import annotations

import contextlib
import logging
import typing
from collections import defaultdict
from collections.abc import Mapping
from dataclasses import dataclass
from typing import Optional, Sequence

import graphviz
from graphviz import Digraph
from metricflow_semantics.collection_helpers.mf_type_aliases import AnyLengthTuple
from metricflow_semantics.collection_helpers.syntactic_sugar import (
    mf_ensure_mapping,
)
from metricflow_semantics.experimental.mf_graph.formatting.dot_attributes import (
    DotEdgeAttributeSet,
    DotGraphAttributeSet,
    DotNodeAttributeSet,
    DotRankKey,
)
from metricflow_semantics.experimental.mf_graph.graph_converter import MetricflowGraphConverter
from typing_extensions import override

if typing.TYPE_CHECKING:
    from metricflow_semantics.experimental.mf_graph.mf_graph import (
        MetricflowGraph,
    )

logger = logging.getLogger(__name__)


@dataclass
class DotGraphConversionResult:
    """The results of converting to a DOT graph."""

    dot_graph: Digraph
    # For debugging context.
    dot_element_set: DotAttributeSet


@dataclass
class DotConversionArgumentSet:
    """Arguments for converting to a DOT graph."""

    # Whether to include graphical attributes when converting the MF graph objects to DOT graph objects.
    include_graphical_attributes: bool
    # The following fields are the attributes used to create the corresponding DOT object (can be overridden by the
    # attributes generated by the MF graph objects).
    cluster_attributes: Mapping[str, str]
    graph_attributes: Mapping[str, str]
    node_attributes: Mapping[str, str]
    edge_attributes: Mapping[str, str]

    @staticmethod
    def create(  # noqa: D102
        include_graphical_attributes: bool = False,
        graph_attributes: Optional[Mapping[str, str]] = None,
        cluster_attributes: Optional[Mapping[str, str]] = None,
        node_attributes: Optional[Mapping[str, str]] = None,
        edge_attributes: Optional[Mapping[str, str]] = None,
    ) -> DotConversionArgumentSet:
        return DotConversionArgumentSet(
            include_graphical_attributes=include_graphical_attributes,
            cluster_attributes=mf_ensure_mapping(cluster_attributes),
            graph_attributes=mf_ensure_mapping(graph_attributes),
            node_attributes=mf_ensure_mapping(node_attributes),
            edge_attributes=mf_ensure_mapping(edge_attributes),
        )


class MetricflowGraphToDotConverter(MetricflowGraphConverter[DotGraphConversionResult]):
    """Convert an MF graph to a DOT graph."""

    def __init__(  # noqa: D107
        self,
        arguments: DotConversionArgumentSet = DotConversionArgumentSet.create(),
    ) -> None:
        self._arguments = arguments

    def _create_dot_attributes(
        self,
        graph: MetricflowGraph,
    ) -> DotAttributeSet:
        cluster_name_to_dot_nodes: dict[Optional[str], AnyLengthTuple[DotNodeAttributeSet]] = {}

        cluster_name_to_nodes: dict[str, list] = defaultdict(list)
        for node in graph.nodes:
            cluster_name_to_nodes[node.node_descriptor.cluster_name].append(node)

        for cluster_name, nodes in cluster_name_to_nodes.items():
            cluster_name_to_dot_nodes[cluster_name] = tuple(
                node.as_dot_node(self._arguments.include_graphical_attributes) for node in sorted(nodes)
            )

        dot_graph = graph.as_dot_graph(self._arguments.include_graphical_attributes)
        dot_graph = DotGraphAttributeSet.create(
            name=dot_graph.name, additional_kwargs=self._arguments.graph_attributes
        ).merge(dot_graph)

        return DotAttributeSet(
            graph_attributes=dot_graph,
            cluster_name_to_node_attributes=cluster_name_to_dot_nodes,
            edge_attributes=tuple(
                edge.as_dot_edge(self._arguments.include_graphical_attributes) for edge in graph.edges
            ),
        )

    @staticmethod
    def create_dot_graph(
        converter_arguments: DotConversionArgumentSet, dot_attribute_set: DotAttributeSet
    ) -> DotGraphConversionResult:
        """Using the supplied attributes, create the DOT graph."""
        dot_graph = DotGraphAttributeSet.create(
            name=dot_attribute_set.graph_attributes.name, additional_kwargs=converter_arguments.graph_attributes
        ).merge(dot_attribute_set.graph_attributes)

        dot = graphviz.Digraph(
            graph_attr=dot_graph.dot_graph_attrs,
            node_attr=converter_arguments.node_attributes,
            edge_attr=converter_arguments.node_attributes,
        )

        all_dot_nodes: list[DotNodeAttributeSet] = []
        for cluster_name, dot_nodes in dot_attribute_set.cluster_name_to_node_attributes.items():
            # A cluster maps to a subgraph, so create the appropriate nodes in the subgraph context.
            # If the cluster is not specified, the node is not created in a subgraph.
            subgraph_context = (
                # Graphviz needs the subgraph to be prefixed with the constant.
                dot.subgraph(
                    name="cluster_" + cluster_name,
                )
                if cluster_name is not None
                else contextlib.nullcontext(enter_result=dot)
            )

            with subgraph_context as subgraph:
                if cluster_name is not None:
                    subgraph.attr(label=cluster_name, **converter_arguments.cluster_attributes)
                added_nodes = MetricflowGraphToDotConverter._add_nodes_with_rank(
                    converter_arguments=converter_arguments, dot_graph=subgraph, dot_nodes=dot_nodes
                )
                all_dot_nodes.extend(added_nodes)

        for dot_edge in dot_attribute_set.edge_attributes:
            dot.edge(**dot_edge.dot_kwargs)

        return DotGraphConversionResult(
            dot_graph=dot,
            dot_element_set=dot_attribute_set,
        )

    @staticmethod
    def _add_nodes_with_rank(
        converter_arguments: DotConversionArgumentSet, dot_graph: Digraph, dot_nodes: Sequence[DotNodeAttributeSet]
    ) -> Sequence[DotNodeAttributeSet]:
        added_dot_nodes: list[DotNodeAttributeSet] = []
        if not converter_arguments.include_graphical_attributes:
            for dot_node in dot_nodes:
                dot_graph.node(**dot_node.dot_kwargs)
                added_dot_nodes.append(dot_node)
                added_dot_nodes.append(dot_node)
            return added_dot_nodes

        rank_key_to_dot_nodes: dict[Optional[DotRankKey], list[DotNodeAttributeSet]] = defaultdict(list)

        for dot_node in dot_nodes:
            rank_key_to_dot_nodes[dot_node.rank_key].append(dot_node)

        for rank_key, dot_nodes in rank_key_to_dot_nodes.items():
            if rank_key is not None:
                graph_attr = {
                    "label": "",
                    "penwidth": "0",
                    "rank": "same",
                }
                subgraph_context = dot_graph.subgraph(
                    name="cluster_" + rank_key.value,
                    graph_attr=graph_attr,
                )
            else:
                subgraph_context = contextlib.nullcontext(enter_result=dot_graph)

            with subgraph_context as dot_subgraph:
                for dot_node in dot_nodes:
                    dot_subgraph.node(**dot_node.dot_kwargs)
                    added_dot_nodes.append(dot_node)

        return added_dot_nodes

    @override
    def convert_graph(self, graph: MetricflowGraph) -> DotGraphConversionResult:
        dot_elements = self._create_dot_attributes(graph)
        return MetricflowGraphToDotConverter.create_dot_graph(self._arguments, dot_elements)


@dataclass
class DotAttributeSet:
    """Attributes for creating a group of objects in DOT."""

    graph_attributes: DotGraphAttributeSet
    # Maps the name of the cluster to the DOT nodes in that cluster.
    cluster_name_to_node_attributes: Mapping[Optional[str], AnyLengthTuple[DotNodeAttributeSet]]
    edge_attributes: AnyLengthTuple[DotEdgeAttributeSet]
